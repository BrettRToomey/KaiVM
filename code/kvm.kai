#import "ops.kai"
#import "conditions.kai"

#library "libc"
#foreign libc {
    mmap   :: (addr: rawptr, len: u64, prot: i32, flags: i32, fd: i32, offset: u64) -> rawptr
    memcpy :: (dest, src: rawptr, size: u64) -> rawptr
    malloc :: (size: u64) -> rawptr
    printf :: (fmt: *u8, args: #cvargs ..any) -> i32
}

RegisterType :: union {
    int: i64
    flt: f64
    str: string
}

RegisterEnum :: enum {
    INT,
    FLOAT,
    STRING
}

Register :: struct {
    value: RegisterType    
    type: RegisterEnum
}

REG_COUNT :: 0xF

VM :: struct {
    registers: [REG_COUNT]Register
    ip: u64
    pgr: []u8
    flags: u8
    running: bool
}

opcodes : [0x100]*(u16, *VM) -> void

initOpcodes :: fn() -> void {
    for i := 0; i < opcodes.len; i += 1 {
        opcodes[i] = &err_unknown_op
    }

    using ops
    opcodes[NOP]  = &nop
    opcodes[HALT] = &halt
    opcodes[ADD]  = &add
    opcodes[SUB]  = &sub

    opcodes[CPY]  = &cpy

    opcodes[JMP]  = &jmp

    // immediates
    opcodes[ADDi] = &addi
    opcodes[LDI]  = &ldi
    opcodes[JMI]  = &jmi
}

dumpRegisters :: fn(vm: *VM) -> void {
    if vm == nil
        return

    for i := 0; i < vm.registers.len; i += 1 {
        if i % 5 == 0 && i != 0
            printf("\n       ".raw)
        printf("r%1x:%04X ".raw, i+1, vm.registers[i].value.int)
    }

    printf("\n".raw)
}

boot :: fn(pgr: []u8) -> *VM, bool {
    if pgr.len == 0
        return nil, false

    vm: *VM = autocast malloc(sizeof(VM))
    if vm == nil
        return nil, false

    vm.pgr = pgr
    vm.ip, vm.flags = 0, 0
    vm.running = true

    for i := 0; i < vm.registers.len; i += 1 {
        vm.registers[i].type = RegisterEnum.INT
        vm.registers[i].value.int = 0
    }

    return vm, true
}

step :: fn(vm: *VM) -> void {
    if vm == nil || !vm.running
        return

    instr: u16
    memcpy(&instr, &(vm.pgr[vm.ip]), sizeof(u16))

    printf("0x%04X ".raw, instr)

    vm.ip += 2

    handler := opcodes[(instr >> 8) & 0xFF]
    handler(instr, vm)
}

loadImmediate :: fn(instr: u16, vm: *VM) -> i64 {
    result: i64 = 0

    size := (instr & 0xF)
    // FIXME: Won't properly handle signed values smaller than 8 bytes
    memcpy(&result, &(vm.pgr[vm.ip]), autocast size)
    vm.ip += cast(u64) size

    return result
}

main :: fn() -> i32 {
    initOpcodes()
    vm, ok := boot([]u8{ 0x10, 0x90, 0x01, 0x82, 0x01, 0x10, 0x20, 0x00})
    if !ok {
        printf("Failed to initialize VM\n".raw)
        return 1
    }

    for vm.running {
        step(vm)
        dumpRegisters(vm)
    }

    return 0
}

err_unknown_op :: fn(instr: u16, vm: *VM) -> void {
    printf("invalid instruction 0x%02X (ip:%d)\n".raw, vm.pgr[vm.ip], vm.ip)
    vm.running = false
}

nop :: fn(instr: u16, vm: *VM) -> void {
}

halt :: fn(instr: u16, vm: *VM) -> void {
    vm.running = false
}

add :: fn(instr: u16, vm: *VM) -> void {
    lreg := (instr & 0xF0) >> 4
    left  := vm.registers[lreg].value.int
    right := vm.registers[instr & 0xF].value.int
    result := left + right
    vm.registers[lreg].value.int = result
    if result == 0
        vm.flags = 1
}

addi :: fn(instr: u16, vm: *VM) -> void {
    lreg := (instr & 0xF0) >> 4
    lhs := vm.registers[lreg].value.int
    rhs := loadImmediate(instr, vm)
    result := lhs + rhs
    vm.registers[lreg].value.int = result
    if result == 0
        vm.flags = 1
}

sub :: fn(instr: u16, vm: *VM) -> void {
    lreg := (instr & 0xF0) >> 4
    left  := vm.registers[lreg].value.int
    right := vm.registers[instr & 0xF].value.int
    result := left - right
    vm.registers[lreg].value.int = result
    if result == 0
        vm.flags = 1
}

cpy :: fn(instr: u16, vm: *VM) -> void {
    lreg := (instr & 0xF0) >> 4
    right := vm.registers[instr & 0xF].value.int
    vm.registers[lreg].value.int = right
    if right == 0
        vm.flags = 1
}

ldi :: fn(instr: u16, vm: *VM) -> void {
    lreg := (instr & 0xF0) >> 4
    rhs := loadImmediate(instr, vm)
    vm.registers[lreg].value.int = rhs
    if rhs == 0
        vm.flags = 1
}

jmp :: fn(instr: u16, vm: *VM) -> void {
    if !conditions.shouldBranch(instr & 0xF, vm.flags)
        return

    lreg := (instr & 0xF0) >> 4
    vm.ip = autocast vm.registers[lreg].value.int
}

jmi :: fn(instr: u16, vm: *VM) -> void {
    address := loadImmediate(instr, vm)

    condition := (instr & 0xF0) >> 4
    if conditions.shouldBranch(condition, vm.flags)
        vm.ip = autocast address
}
