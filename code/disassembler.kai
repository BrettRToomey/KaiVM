#import "ops.kai"
#import "conditions.kai"
#library "libc"
#foreign libc {
    memcpy :: (dest, src: rawptr, size: u64) -> rawptr
    malloc :: (size: u64) -> rawptr
    printf :: (fmt: *u8, args: #cvargs ..any) -> i32
    strlen :: (str: *u8) -> u64
    fopen  :: (path: *u8, mode: *u8) -> rawptr
    fread  :: (ptr: rawptr, size: u64, nmemb: u64, file: rawptr) -> u64
}

loadImmediate :: fn(instr: u16, code: []u8, ip: *u64) -> i64 {
    result: i64 = 0

    size := (instr & 0xF)
    // FIXME: Won't properly handle signed values smaller than 8 bytes
    memcpy(&result, &code[<ip], autocast size)
    <ip += cast(u64) size

    return result
}

checkFileType :: fn(input: string) -> bool {
    if input.len < 3
        return false

    s := input.len - 4
    if input[s] != 0x2E || input[s+1] != 0x62 || input[s+2] != 0x63
        return false

    return true
}

disassemble :: fn(code: []u8) -> bool {
    ip : u64 = 0
    for ip < code.len {
        instr: u16
        memcpy(&instr, &(code[ip]), sizeof(u16))
        ip += 2

        name := ops.getName(instr)
        opcode := (instr >> 8) & 0x7F
        if opcode == ops.HALT || opcode == ops.NOP {
            printf("%s\n".raw, name)
            continue
        }

        if opcode == ops.JMP {
            cond := conditions.getJmpName(instr)
            printf("%s ".raw, cond.raw)
            if (instr >> 8) & 0x80 != 0 {
                immediate := loadImmediate(instr, code, &ip)
                printf("%xh\n".raw, immediate)
            } else {
                rreg := (instr & 0xF0) >> 4
                printf("r%d\n".raw, rreg + 1)
            }

            continue
        }

        lreg := (instr & 0xF0) >> 4
        printf("%s r%d".raw, name.raw, lreg + 1)

        if (instr >> 8) & 0x80 != 0 {
            immediate := loadImmediate(instr, code, &ip)
            printf(", %xh\n".raw, immediate)
        } else {
            rreg := instr & 0xF
            printf(", r%d\n".raw, rreg + 1)
        }
    }

    return true
}

main :: fn(argc: i32, argv: **u8) -> i32 {
    if argc < 2 {
        printf("error: no input files\n".raw)
        return 1
    }

    path: string
    len := strlen(argv[1])
    path.raw = argv[1]
    path.len = len + 1
    
    if !checkFileType(path) {
        printf("error: invalid file type. expected: <input>.bc\n".raw)
        return 2
    }

    input := fopen(path.raw, "rb".raw)
    if input == nil {
        printf("error: could not open file: '%s'\n".raw, path.raw)
        return 3
    }

    buff: [1024]u8
    count := fread(&buff[0], 1, buff.len, input)

    code: []u8
    code.raw = &buff[0]
    code.len = count

    ok := disassemble(code)
    if !ok {
        return 4
    }

    return 0
}
